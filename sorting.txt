Sorting in C++

sorting in arrays:

#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	
	int arr[]={10,20,5,7};
	int n = sizeof(arr) / sizeof(arr[0]);
	
	sort(arr,arr+n); // takes two arguments which are the index of the first element and the index after the last element.  // 5.7.10,20
	
	for(int x: arr)
	    cout<<x<<" ";
	
	sort(arr,arr+n,greater<int>());    // greater<int> reverses the order of the array that was sorted in increasing order. o/p: 20,10,7,5
	
	cout<<endl;
	for(int x: arr)
	    cout<<x<<" ";
}

SORTING IN VECTORS:


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	
    vector<int> v={10,20,5,7};
	
	sort(v.begin(),v.end());
	
	for(int x: v)
	    cout<<x<<" ";
	
	sort(v.begin(),v.end(),greater<int>());
	
	cout<<endl;
	for(int x: v)
	    cout<<x<<" ";
}

SORTING OF OWN ORDER USING STRUCT:

Here we- sort the pairs with increasing order of their x values.


#include <iostream>
#include <algorithm>
using namespace std;

struct Point{
    int x,y;
};

bool MyComp(Point p1,Point p2){
    return p1.x<p2.x;
}

int main() {
	
    Point arr[]={{3,10},{2,8},{5,4}};    O/P: {2,8}, {3,10}, {5,4}
	int n=sizeof(arr)/sizeof(arr[0]);
	sort(arr,arr+n,MyComp);
	
	for(auto i: arr)
	    cout<<i.x<<" "<<i.y<<endl;
}

TIME COMPLEXITY OF SORT FUNCTION IS: USES INTRO SORT(HYBRID OF QUICK SORT, HEAP SORT AND INSERTION SORT):-> O(nlogn)

STABILITY IN SORTING ALGORITHM:



------------------------------------------------------------------------------------------------------------------------------------------------------------------
BUBBLE SORT ALGORITHM:  O(n2)

bubble sort compares the curretn element with the adjacent element and swaps it if it is out of order.
ex: 2,10,8,7

1st phase: maximum element reaches to its final position:
 2,8,7,10
2nd phase: the second last position will be filled witht the secomd largest element.
 2,7,8,10
 3rd phase: the third last position will be filled with the third largest elemetnt
 
 so we can just simply ignore already sorted last elements in every iteration to reduce the time complexity. so we can make the change in the loop as
 j<n-i-1.
 
 void bubbleSort(int arr[], int n){
    for(int i = 0;i < n; i++){
        for(int j = 0 ; j < n - i -1; j++){
            if( arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

now what if the array is already sorted and still it takes O(n2) time to check it again. to save the time we can optimize the code 

#include<bits/stdc++.h>
using namespace std;

void bubbleSort(int arr[], int n){
    
    bool swapped;
    for(int i = 0;i < n; i++){
        
        swapped = false;
        for(int j = 0 ; j < n - i -1; j++){
            if( arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        
        if( swapped == false)
        break;
    }
}

int main() {
	int a[] = {2, 1, 3, 4};
	bubbleSort(a, 4);
	for(int i = 0; i < 4; i++){
	    cout<<a[i]<<" ";
	}
	return 0;
}

Bubble sort is a stability algorithm, it never changes the values which are equal.
----------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECTION SORT ALGORITHM: O(n2)
does less memory writes compared to other algorithms like quicksort, mergesort, insertionsort etc....but cycle sort is optimal in terms of memory writes.
--basic idea for heap sort.
--Not stable

The algorithm works like it checks the smallest element in the array and swaps it with the element in the first position. And again check the next smallest element and swaps it with the element in the next index. 

#include<bits/stdc++.h>
using namespace std;

void bubbleSort(int arr[], int n){
    
    bool swapped;
    for(int i = 0;i < n; i++){
        
        swapped = false;
        for(int j = 0 ; j < n - i -1; j++){
            if( arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        
        if( swapped == false)
        break;
    }
}

int main() {
	int a[] = {2, 1, 3, 4};
	bubbleSort(a, 4);
	for(int i = 0; i < 4; i++){
	    cout<<a[i]<<" ";
	}
	return 0;
}

-------------------------------------------------------------------------------------------

INSERTION SORT:

--O(n2) worst case
--In place and stable(in place is where the algorithm does not take any extra space.
(stable in the senese if there are two equal values their original order in which they occur will be retained in the same way)
--Used in practise for small arrays(Timsort and Introsort)
-O(n) in best case

[20,5,40,60,10,30]
[5,20,40,60,10,30] // 5 goes to its correct position in the current sorted sub array
[5.20.40.60.10.30] //20 is already in the correct order in current sorted sub array
[5,20,40,60,10,30] // 40 is already in correct order
[5.20,40,60,10,30] // 60 is already in correct order
[5.10.20,40,60,30] // 10 will be placed in its correct position 
[5,10,20,30,40,60] // 30 will be placed in its correct position

#include <iostream>
#include <algorithm>
using namespace std;

void iSort(int arr[],int n){
    
    for(int i=1;i<n;i++){
        int key = arr[i];
        int j=i-1;
        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
}

int main() {
	
    int arr[]={50,20,40,60,10,30};
	
	int n=sizeof(arr)/sizeof(arr[0]);
	iSort(arr,n);
	
	for(auto x: arr)
	    cout<<x<<" ";
}


worst case: O(n2) when the array is in reverse sorted order.
best case: O(n) wjen it is already sorted
----------------------------------------------------------------------------------------------------------------------------------------------------------------

MERGE SORT ALGORITHM:

-- its a divide and conquer algorithm(divide, conquer and merge)
-- stable algorithm
-- theta(nlogn) time and O(n) aux space
-- well suited for linked lists. works in O(n) aux space
-- used in external sorting
--In general for arrays, quicksort outperforms merge sort


MERGE TWO SORTED ARRAYS:

I/P: A[] = {10,15,20}
     B[] = {5,6,6,15}
O/P: 5 6 6 10 15 15 20

This can be done effectively by the idea of two pointer approach.
pointer i for the array A[] and pointer j for array B[]

#include <iostream>
#include <algorithm>
using namespace std;

void merge(int a[], int b[], int m, int n){
    
    int i=0,j=0;
    while(i<m && j<n){
        if(a[i]<=b[j]) // a[i]<=b[j] ensures that the correct of the equal values in which they 
            cout<<a[i++]<<" ";   //are appear in the array
        else
            cout<<b[j++]<<" ";
    }
    while(i<m)
        cout<<a[i++]<<" ";
    while(j<n)
        cout<<b[j++]<<" ";    
}

Merge function of Merge sort
This video is a complex version of the previously discussed problem on Merge Sort. Here we take a single array with three points namely, the lower, the middle and the highest point. The elements from the lower to the middle are sorted and the elements from the (middle+1) to the higher are sorted. The task is to merge these two sorted parts into one.


In this function we may be asked to sort some part of the array in which we should first know the indexes of this array like leftmost index, mid index and right most index. so we should be aware of implementing the logic by considering this.

void merge(int arr[], int l, int m, int h){
    
    int n1=m-l+1, n2=h-m;
    int left[n1],right[n2];
    for(int i=0;i<n1;i++)
        left[i]=arr[i+l];
    for(int j=0;j<n2;j++)
        right[j]=arr[m+1+j];    
    int i=0,j=0,k=l;
    while(i<n1 && j<n2){
        if(left[i]<=right[j])
            arr[k++]=left[i++];
        else
            arr[k++]=right[j++];
    }
    while(i<n1)
        arr[k++]=left[i++];
    while(j<n2)
        arr[k++]=right[j++];    
}


MERGESORT ALGORITHM: refer video for better understanding.

#include <iostream>
#include <algorithm>
using namespace std;

void merge(int arr[], int l, int m, int h){
    
    int n1=m-l+1, n2=h-m;
    int left[n1],right[n2];
    for(int i=0;i<n1;i++)
        left[i]=arr[i+l];
    for(int j=0;j<n2;j++)
        right[j]=arr[m+1+j];    
    int i=0,j=0,k=l;
    while(i<n1 && j<n2){
        if(left[i]<=right[j])
            arr[k++]=left[i++];
        else
            arr[k++]=right[j++];
    }
    while(i<n1)
        arr[k++]=left[i++];
    while(j<n2)
        arr[k++]=right[j++];    
}

void mergeSort(int arr[],int l,int r){
    if(r>l){
        int m=l+(r-l)/2;
        mergeSort(arr,l,m);
        mergeSort(arr,m+1,r);
        merge(arr,l,m,r);
    }
}

int main() {
	
    int a[]={10,5,30,15,7};
	int l=0,r=4;
	
	mergeSort(a,l,r);
	for(int x: a)
	    cout<<x<<" ";
}


working of recursive calls:
void mergeSort(int arr[],int l,int r){
    if(r>l){
        int m=l+(r-l)/2;
        mergeSort(arr,l,m);
        mergeSort(arr,m+1,r);
        merge(arr,l,m,r);
    }
}
 
 for array [10,5,30,15,7]
 m = l+r/2 = 2
 
 
                              10  5  30  15  7
                              l=0    m=2     r=4
			    /			\
		     10  5  30		        15      7			
		    l=0 m=1 r=2		       l=3 m=3 r=4
		   /	        \		/         \
		10  5 		 30          15           7
	       l=m=0 r=1         l=2 r=2   l=3 r=3       l=r=4
	      /       \
	    10         5
	   l=0 r=0    l=1 r=1

mergesort() function will just calls the array recursively by breaking it into parts.
merge() function did the actual sorting

After completing the calls, we get the below modified array.
	                       5  7  10  15  30
                              l=0    m=2     r=4
			    /			\
		     5  10  30		        7      15			
		    l=0 m=1 r=2		       l=3 m=3 r=4
		   /	        \		/         \
		5  10 		 30          15           7
	       l=m=0 r=1         l=2 r=2   l=3 r=3       l=r=4
	      /       \
	    5         10
	   l=0 r=0    l=1 r=1

Time complexity of merge sort algorithm is theta(nlogn)
Auxilary space is theta(n) space

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
NAIVE PARTITION:
Naive partition is stable where lomuto and hoare are not stable.

Have 4 traversals with time complexity of: O(n) and auxilary space of O(n).
#include <bits/stdc++.h>
using namespace std;

void partition(int arr[], int l, int h, int p)
{
    int temp[h-l+1],index=0;
    for(int i=l;i<=h;i++)
        if(arr[i]<=arr[p] && i != p)
            {
                temp[index]=arr[i];index++;
            }
    temp[index++] = arr[p];
    for(int i=l;i<=h;i++)
        if(arr[i]>arr[p])
            {
                temp[index]=arr[i];index++;
            }
    for(int i=l;i<=h;i++)
        arr[i]=temp[i-l];
}
 
int main() {
	
    int arr[]={5,13,6,9,12,11,8};
	
	int n=sizeof(arr)/sizeof(arr[0]);
	
	partition(arr,0,n-1,3);
	
	for(int x: arr)
	    cout<<x<<" ";
}

But lomuto and hoare algorithms have only one traversal with the same time complexity but these two algorithms are not stable.

LOMUTO ALGORITHM: Lomuto partition partitions an array around the array in O(n)time with O(1) extra space.
It takes the last element as its pivot and it places that element in its correct position inthe array and keeps all the smaller elements to left of it in ANY ORDER and all the greater elements to its right IN ANY ORDER.

It always has pivot element to be the last element of the array. And it maintains two variables to keep track of smaller elements window and the indexes of the array. 
For the input: {10,80,30,90,40,50,70}
n = 7
l = 0
h = n-1 = 6, pivot = arr[h] = 70
j = 0
i = l-1 = -1

i=-1, j = 0  => {10,80,30,90,40,40,70} swap(arr[i],arr[j]) = 10 swaps by itself here.

smallest elements window increases as i++
i = 0, j =1 => {10,80,30,90,40,50,70} since 80>70 no swapping is done
i = 0, j = 2 =>{10,30,80,90,40,50,70} 30<70 swaps(80,30)
i = 1, j = 3 => {10,30,80,90,40,50,70} 90>70
i = 1, j = 4 => {10,30,40,90,80,50,70} 40<70 swaps(80,40)
i = 2, j = 5 => {10,30,40,50,80,90,70} 50<70 swaps(90,50)
i = 3, j = 6 => loops stopes here
all the smallest elemenst window is upto index 3 and all the gretaest elements are from index 4 to index 5.
after the loop, we swaps the pivot element with next greatest element
{10,30,40,50,70,80,90}
index of pivot is now at index 4.

int iPartition(int arr[], int l, int h)
{   
    int pivot=arr[h];
    int i=l-1;
    for(int j=l;j<=h-1;j++){
        if(arr[j]<pivot){
            i++;
            swap(arr[i],arr[j]);
        }
    }
    swap(arr[i+1],arr[h]);
    return i+1;
}


HOARES PARTITION ALGORITHM:

works nbetter than lomuto partition. works in O(n) O(n) time and O(1) extra space.
 In hoares partition the pivot element is arr[low] which is the value of first index
 
 so for the array {5,3,8,4,2,7,1,10}
 i = l-1, j = h+1
 pivot = arr[l] = 5
 
 i = -1, j = 8
 {5,3,8,4,2,7,1,10} the loop stops at i = 0, j = 6 since arr[j]<pivot 
 	swaps: 5 and 1 = {1,3,8,4,2,7,5,10}
{1,3,8,4,2,7,5,10} = > again stops at i=2, j = 4	
	swaps: 8 and 2 {1,3,2,4,8,7,5,10}
finally i = 4 and j = 3 where they crossed each other

In lomuto partition the pivot element will be placed at his postion where it has to be but in hoares partition the pivot will not be at its correct position, but hoares partition takes less number of comparisons then lomuto partition.

int partition(int arr[], int l, int h)
{   
    int pivot=arr[l];
    int i=l-1,j=h+1;
    while(true){
        do{
            i++;
        }while(arr[i]<pivot);
        do{
            j--;
        }while(arr[j]>pivot);
        if(i>=j)return j;
        swap(arr[i],arr[j]);
    }
}

QUICKSORT ALGORITHM:

--divide and conquer algorithm
--worst case time:O(n2)
--despite O(n2) worst case, it is considered faster because of the following reasons:
	-In place
	-cache friendly
	-average case is O(nlogn)
	-Tail recursive
-- partition is key function(Naive,lomuto,hoares)

QUICKSORT USING LOMUTO PARTITION:
#include <bits/stdc++.h>
using namespace std;

int iPartition(int arr[], int l, int h)
{   
    int pivot=arr[h];
    int i=l-1;
    for(int j=l;j<=h-1;j++){
        if(arr[j]<pivot){
            i++;
            swap(arr[i],arr[j]);
        }
    }
    swap(arr[i+1],arr[h]);
    return i+1;
}

void qSort(int arr[],int l,int h){
    if(l<h){
        int p=iPartition(arr,l,h);  // it finds the correct position of the pivot element and
        qSort(arr,l,p-1);	    // sort all the smaller elemenst on its left and
        qSort(arr,p+1,h);	    // sorts all the larger elements on its right.(recursive calls)
    }
}
 
int main() {
	
    int arr[]={8,4,7,9,3,10,5};
	
	int n=sizeof(arr)/sizeof(arr[0]);
	
	qSort(arr,0,n-1);
	
	for(int x: arr)
	    cout<<x<<" ";
}

lets take the array of {8 4 7 9 3 10 5}

						qsort(0,6)
					      8 4 7 9 3 10 5  // 4 3 5 9 8 10 7 (after lomuto partition for qsort(0,6))
					     / 		    \
					 qsort(0,1)        qsort(3,6)
					 4 3 		    9 8 10 7
					/   \	            /      \
			     qsort(0,-1)   qs(1,1)        qs(3,2)   qs(4,6)
				  4   		3		   8 10 9
								  /       \
							       qs(4,4)	 qs(6,6)  
							       
				After the completion of the qsort function:
				
					         qsort(0,6)
					      4 3 5 9 8 10 7  
					     / 		    \
					 qsort(0,1)        qsort(3,6)
					 3 4 		    7 8 9 10
					/   \	            /      \
			     qsort(0,-1)   qs(1,1)        qs(3,2)   qs(4,6)
				     				   8 9 10
								  /       \
							       qs(4,4)	 qs(6,6)  


QUICKSORT USING HOARES PARTITION:
#include <bits/stdc++.h>
using namespace std;

int partition(int arr[], int l, int h)
{   
    int pivot=arr[l];
    int i=l-1,j=h+1;
    while(true){
        do{
            i++;
        }while(arr[i]<pivot);
        do{
            j--;
        }while(arr[j]>pivot);
        if(i>=j)return j;
        swap(arr[i],arr[j]);
    }
}

void qSort(int arr[],int l,int h){
    if(l<h){
        int p=partition(arr,l,h);
        qSort(arr,l,p); // this is where hoares qsort differs from lomuto qsort functionqsort(arr,l,p-1). Lomuto already fixes the pivot and starts the partitions on  
        qSort(arr,p+1,h); // left and right side but in hoares pivot is not fixed so it includes it.
    }
}
 
int main() {
	
    int arr[]={8,4,7,9,3,10,5};
	
	int n=sizeof(arr)/sizeof(arr[0]);
	
	qSort(arr,0,n-1);
	
	for(int x: arr)
	    cout<<x<<" ";
}

In hoares partition, we consider first element as pivot and keeps all the elements smaller than pivot on left side and all the elements greater than pivot on right side.



      							qsort(0,6)
					             8 4 7 9 3 10 5  // 4 3 5 9 8 10 7 (after lomuto partition for qsort(0,6))
					            / 		    \
					        qsort(0,3)        qsort(4,6)
					        5 4 7 3  	    9 10 8
					         /   \	            /      \
			                qsort(0,1)   qs(2,3)     qs(4,4)   qs(5,6)
				          3 4   	7 5	 8	      10 9
					/    \	      /    \		     /     \
				    qs(0,0)  qs(1,1)  5	    7	  qs(2,2)  qs(3,3)  qs(5,5)  qs(6,6)  
					3	 4    		  	       9        10
					
After calling the qsort function the tree looks like:
							qsort(0,6)
					            5 4 7 3 9 10 8  // 4 3 5 9 8 10 7 (after lomuto partition for qsort(0,6))
					            / 		    \
					        qsort(0,3)        qsort(4,6)
					        3 4 7 5  	    8 9 10
					         /   \	            /      \
			                qsort(0,1)   qs(2,3)     qs(4,4)   qs(5,6)
				          3 4   	5 7	 8	      9 10
					/    \	      /    \		     /     \
				    qs(0,0)  qs(1,1)  5	    7	  qs(2,2)  qs(3,3)  qs(5,5)  qs(6,6)  
					3	 4    		  	       9        10
										
 Hoares partition is unstable but 3 times faster than lomuto where lomuto is stable. But naive partition is stable but takes more space and traversals.
































































==================================================================================================================================================================
Given an array of integers. Find the Inversion Count in the array. 

Inversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If array is already sorted then the inversion count is 0. If an array is sorted in the reverse order then the inversion count is the maximum. 
Formally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.
 

Example 1:

Input: N = 5, arr[] = {2, 4, 1, 3, 5}
Output: 3
Explanation: The sequence 2, 4, 1, 3, 5 
has three inversions (2, 1), (4, 1), (4, 3).

#include <bits/stdc++.h>
using namespace std;

int countAndMerge(int arr[], int l, int m, int r)
{
    int n1=m-l+1, n2=r-m;
    int left[n1],right[n2];
    for(int i=0;i<n1;i++)
        left[i]=arr[i+l];
    for(int j=0;j<n2;j++)
        right[j]=arr[m+1+j];    
    int res=0,i=0,j=0,k=l;
    while(i<n1 && j<n2){
        if(left[i]<=right[j])
            {arr[k++]=left[i++];}
        else{
            arr[k++]=right[j++];
            res=res+(n1-i);
        }
    }
    while(i<n1)
        arr[k++]=left[i++];
    while(j<n2)
        arr[k++]=right[j++];
    return res;
}

int countInv(int arr[], int l, int r)
{
    int res = 0;
    if (l<r) {
       
        int m = (r + l) / 2;
 
        res += countInv(arr, l, m);
        res += countInv(arr, m + 1, r);
        res += countAndMerge(arr, l, m , r);
    }
    return res;
}
 
int main() {
	
    int arr[]={2,4,1,3,5};
	
	int n=sizeof(arr)/sizeof(arr[0]);
	
	cout<<countInv(arr,0,n-1);
}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Union of Two Sorted Arrays 
Union of two arrays can be defined as the common and distinct elements in the two arrays.
Given two sorted arrays of size n and m respectively, find their union.


Example 1:

Input: 
n = 5, arr1[] = {1, 2, 3, 4, 5}  
m = 3, arr2 [] = {1, 2, 3}
Output: 1 2 3 4 5
Explanation: Distinct elements including 
both the arrays are: 1 2 3 4 5.

vector<int> findUnion(int arr1[], int arr2[], int n, int m)
    {
        //Your code here
        //return vector with correct order of elements
        vector<int> res;
        int i = 0, j = 0;
        while(i<n && j<m){
            if(arr1[i] == arr1[i-1] and i!=0) i++;
            else if(arr2[j] == arr2[j-1] and j!=0) j++;
            else{
                if(arr1[i]>arr2[j]){
                res.push_back(arr2[j]);
                j++;
            }
            else if(arr1[i]<arr2[j]){
                res.push_back(arr1[i]);
                i++;
            }
            else if(arr1[i] == arr2[j]){
                res.push_back(arr1[i]);
                i++;
                j++;
            } 
            }
            
        }
        while(i<n){
            if(arr1[i]!=arr1[i-1]) 
            res.push_back(arr1[i]);
            i++;
        }
        while(j<m){
            if(arr2[j]!=arr2[j-1]) 
            res.push_back(arr2[j]);
            j++;
        }
        return res;
    }
    
    
    
  


