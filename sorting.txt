Sorting in C++

sorting in arrays:

#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	
	int arr[]={10,20,5,7};
	int n = sizeof(arr) / sizeof(arr[0]);
	
	sort(arr,arr+n); // takes two arguments which are the index of the first element and the index after the last element.  // 5.7.10,20
	
	for(int x: arr)
	    cout<<x<<" ";
	
	sort(arr,arr+n,greater<int>());    // greater<int> reverses the order of the array that was sorted in increasing order. o/p: 20,10,7,5
	
	cout<<endl;
	for(int x: arr)
	    cout<<x<<" ";
}

SORTING IN VECTORS:

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	
    vector<int> v={10,20,5,7};
	
	sort(v.begin(),v.end());
	
	for(int x: v)
	    cout<<x<<" ";
	
	sort(v.begin(),v.end(),greater<int>());
	
	cout<<endl;
	for(int x: v)
	    cout<<x<<" ";
}

SORTING OF OWN ORDER USING STRUCT:

Here we- sort the pairs with increasing order of their x values.


#include <iostream>
#include <algorithm>
using namespace std;

struct Point{
    int x,y;
};

bool MyComp(Point p1,Point p2){
    return p1.x<p2.x;
}

int main() {
	
    Point arr[]={{3,10},{2,8},{5,4}};    O/P: {2,8}, {3,10}, {5,4}
	int n=sizeof(arr)/sizeof(arr[0]);
	sort(arr,arr+n,MyComp);
	
	for(auto i: arr)
	    cout<<i.x<<" "<<i.y<<endl;
}

TIME COMPLEXITY OF SORT FUNCTION IS: USES INTRO SORT(HYBRID OF QUICK SORT, HEAP SORT AND INSERTION SORT):-> O(nlogn)

STABILITY IN SORTING ALGORITHM:



------------------------------------------------------------------------------------------------------------------------------------------------------------------
BUBBLE SORT ALGORITHM:  O(n2)

bubble sort compares the curretn element with the adjacent element and swaps it if it is out of order.
ex: 2,10,8,7

1st phase: maximum element reaches to its final position:
 2,8,7,10
2nd phase: the second last position will be filled witht the secomd largest element.
 2,7,8,10
 3rd phase: the third last position will be filled with the third largest elemetnt
 
 so we can just simply ignore already sorted last elements in every iteration to reduce the time complexity. so we can make the change in the loop as
 j<n-i-1.
 
 void bubbleSort(int arr[], int n){
    for(int i = 0;i < n; i++){
        for(int j = 0 ; j < n - i -1; j++){
            if( arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

now what if the array is already sorted and still it takes O(n2) time to check it again. to save the time we can optimize the code 

#include<bits/stdc++.h>
using namespace std;

void bubbleSort(int arr[], int n){
    
    bool swapped;
    for(int i = 0;i < n; i++){
        
        swapped = false;
        for(int j = 0 ; j < n - i -1; j++){
            if( arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        
        if( swapped == false)
        break;
    }
}

int main() {
	int a[] = {2, 1, 3, 4};
	bubbleSort(a, 4);
	for(int i = 0; i < 4; i++){
	    cout<<a[i]<<" ";
	}
	return 0;
}

Bubble sort is a stability algorithm, it never changes the values which are equal.
----------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECTION SORT ALGORITHM: O(n2)
does less memory writes compared to other algorithms like quicksort, mergesort, insertionsort etc....but cycle sort is optimal in terms of memory writes.
--basic idea for heap sort.
--Not stable

The algorithm works like it checks the smallest element in the array and swaps it with the element in the first position. And again check the next smallest element and swaps it with the element in the next index. 

#include<bits/stdc++.h>
using namespace std;

void bubbleSort(int arr[], int n){
    
    bool swapped;
    for(int i = 0;i < n; i++){
        
        swapped = false;
        for(int j = 0 ; j < n - i -1; j++){
            if( arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        
        if( swapped == false)
        break;
    }
}

int main() {
	int a[] = {2, 1, 3, 4};
	bubbleSort(a, 4);
	for(int i = 0; i < 4; i++){
	    cout<<a[i]<<" ";
	}
	return 0;
}

-------------------------------------------------------------------------------------------

INSERTION SORT:

--O(n2) worst case
--In place and stable(in place is where the algorithm does not take any extra space.
(stable in the senese if there are two equal values their original order in which they occur will be retained in the same way)
--Used in practise for small arrays(Timsort and Introsort)
-O(n) in best case

[20,5,40,60,10,30]
[5,20,40,60,10,30] // 5 goes to its correct position in the current sorted sub array
[5.20.40.60.10.30] //20 is already in the correct order in current sorted sub array
[5,20,40,60,10,30] // 40 is already in correct order
[5.20,40,60,10,30] // 60 is already in correct order
[5.10.20,40,60,30] // 10 will be placed in its correct position 
[5,10,20,30,40,60] // 30 will be placed in its correct position

#include <iostream>
#include <algorithm>
using namespace std;

void iSort(int arr[],int n){
    
    for(int i=1;i<n;i++){
        int key = arr[i];
        int j=i-1;
        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
}

int main() {
	
    int arr[]={50,20,40,60,10,30};
	
	int n=sizeof(arr)/sizeof(arr[0]);
	iSort(arr,n);
	
	for(auto x: arr)
	    cout<<x<<" ";
}


worst case: O(n2) when the array is in reverse sorted order.
best case: O(n) wjen it is already sorted
----------------------------------------------------------------------------------------------------------------------------------------------------------------

MERGE SORT ALGORITHM:

-- its a divide and conquer algorithm(divide, conquer and merge)
-- stable algorithm
-- theta(nlogn) time and O(n) aux space
-- well suited for linked lists. works in O(n) aux space
-- used in external sorting
--In general for arrays, quicksort outperforms merge sort


MERGE TWO SORTED ARRAYS:

I/P: A[] = {10,15,20}
     B[] = {5,6,6,15}
O/P: 5 6 6 10 15 15 20

This can be done effectively by the idea of two pointer approach.
pointer i for the array A[] and pointer j for array B[]

#include <iostream>
#include <algorithm>
using namespace std;

void merge(int a[], int b[], int m, int n){
    
    int i=0,j=0;
    while(i<m && j<n){
        if(a[i]<=b[j]) // a[i]<=b[j] ensures that the correct of the equal values in which they 
            cout<<a[i++]<<" ";   //are appear in the array
        else
            cout<<b[j++]<<" ";
    }
    while(i<m)
        cout<<a[i++]<<" ";
    while(j<n)
        cout<<b[j++]<<" ";    
}

Merge function of Merge sort
This video is a complex version of the previously discussed problem on Merge Sort. Here we take a single array with three points namely, the lower, the middle and the highest point. The elements from the lower to the middle are sorted and the elements from the (middle+1) to the higher are sorted. The task is to merge these two sorted parts into one.

void merge(int arr[], int l, int m, int h){
    
    int n1=m-l+1, n2=h-m;
    int left[n1],right[n2];
    for(int i=0;i<n1;i++)
        left[i]=arr[i+l];
    for(int j=0;j<n2;j++)
        right[j]=arr[m+1+j];    
    int i=0,j=0,k=l;
    while(i<n1 && j<n2){
        if(left[i]<=right[j])
            arr[k++]=left[i++];
        else
            arr[k++]=right[j++];
    }
    while(i<n1)
        arr[k++]=left[i++];
    while(j<n2)
        arr[k++]=right[j++];    
}


MERGESORT ALGORITHM: refer video for better understanding.

#include <iostream>
#include <algorithm>
using namespace std;

void merge(int arr[], int l, int m, int h){
    
    int n1=m-l+1, n2=h-m;
    int left[n1],right[n2];
    for(int i=0;i<n1;i++)
        left[i]=arr[i+l];
    for(int j=0;j<n2;j++)
        right[j]=arr[m+1+j];    
    int i=0,j=0,k=l;
    while(i<n1 && j<n2){
        if(left[i]<=right[j])
            arr[k++]=left[i++];
        else
            arr[k++]=right[j++];
    }
    while(i<n1)
        arr[k++]=left[i++];
    while(j<n2)
        arr[k++]=right[j++];    
}

void mergeSort(int arr[],int l,int r){
    if(r>l){
        int m=l+(r-l)/2;
        mergeSort(arr,l,m);
        mergeSort(arr,m+1,r);
        merge(arr,l,m,r);
    }
}

int main() {
	
    int a[]={10,5,30,15,7};
	int l=0,r=4;
	
	mergeSort(a,l,r);
	for(int x: a)
	    cout<<x<<" ";
}


working of recursive calls:
void mergeSort(int arr[],int l,int r){
    if(r>l){
        int m=l+(r-l)/2;
        mergeSort(arr,l,m);
        mergeSort(arr,m+1,r);
        merge(arr,l,m,r);
    }
}
 
 for array [10,5,30,15,7]
 m = l+r/2 = 2
 
 
                              10  5  30  15  7
                              l=0    m=2     r=4
			    /			\
		     10  5  30		        15      7			
		    l=0 m=1 r=2		       l=3 m=3 r=4
		   /	        \		/         \
		10  5 		 30          15           7
	       l=m=0 r=1         l=2 r=2   l=3 r=3       l=r=4
	      /       \
	    10         5
	   l=0 r=0    l=1 r=1

mergesort() function will just calls the array recursively by breaking it into parts.
merge() function did the actual sorting

After completing the calls, we get the below modified array.
	                       5  7  10  15  30
                              l=0    m=2     r=4
			    /			\
		     5  10  30		        7      15			
		    l=0 m=1 r=2		       l=3 m=3 r=4
		   /	        \		/         \
		5  10 		 30          15           7
	       l=m=0 r=1         l=2 r=2   l=3 r=3       l=r=4
	      /       \
	    5         10
	   l=0 r=0    l=1 r=1

Time complexity of merge sort algorithm is theta(nlogn)
Auxilary space is theta(n) space


