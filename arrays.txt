         --------------------------- ARRAYS DATA STRUCTURE  ----------------------------------------------
 
 VECTORS IN C++:
	ADVANATGES OF VECTORS IN C++:
		- dynamic size
		-rich library functions find,erase, insert etc..
		-easy to know the size
		-no need to pass size
		-can be returned from a functions
		-by default initialized with default values
		- we can copy a vector to other easily, v1=v2 copies all elements of v2 to v1

-------------------------------------------------------


OPERATION ON ARRAYS:
	Searching an element in an array and returns its index position.
	
	In unsorted array: O(n) time complexity.
	int search(int arr[], int n, int x)
		{
			for(int i = 0; i < n; i++)
			{
				if(arr[i] == x)
					return i;
			}

			return -1;
		}
		
	Inserting an element in an array only there is extra space in the array.
	int insert(int arr[], int n, int x, int cap, int pos)
		{
			if(n == cap)
				return n;

			int idx = pos - 1;

			for(int i = n - 1; i >= idx; i--)
			{
				arr[i + 1] = arr[i];
			}

			arr[idx] = x;

			return n + 1;
		} 
	Deletion of an element in an array
	int deleteEle(int arr[], int n, int x)
		{
			int i = 0;

			for(i = 0; i < n; i++)
			{
				if(arr[i] == x)
					break;
			}

			if(i == n)
				return n;

			for(int j = i; j < n - 1; j++)
			{
				arr[j] = arr[j + 1];
			}

			return n-1;
		} 
TIME COMPLEXITIES OF ALL OPERATIONS:
	Insert: O(n)
	Search: O(n) for unsorted
			O(logn) for sorted
	Delete: O(n)
	Getting ith element & updating ith element:  O(1)
--------------------------------------------------------------------

LARGEST ELEMENT IN AN ARRAY:
--------------------------------------------------------------------

CHECK IF AN ARRAY IS SORTED OR NOT:

#include <iostream>
#include <cmath>
using namespace std;

bool isSorted(int arr[], int n)
{
	for(int i = 1; i < n; i++)
	{
	    if(arr[i] < arr[i - 1])
	        return false;
	}

	return true;
} 

    
int main() {
	
      int arr[] = {5, 12, 30, 2, 35}, n = 5;
      
      printf("%s", isSorted(arr, n)? "true": "false");
    
}
---------------------------------------------------------------------
REVERSE OF AN ARRAY:

#include <iostream>
#include <cmath>
using namespace std;

 void reverse(int arr[], int n)
{
	int low = 0, high = n - 1;

	while(low < high)
	{
		int temp = arr[low];

		arr[low] = arr[high];

		arr[high] = temp;

		low++;
		high--;
	}
}

    
int main() {
	
      int arr[] = {10, 5, 7, 30}, n = 4;

      cout<<"Before Reverse"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }

       cout<<endl;

       reverse(arr, n);

       cout<<"After Reverse"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }
    
}
-----------------------------------------------------------------------
REMOVE DUPLICATES FROM THE SORTED ARRAY: Two Pointer algorithm:


GIVEN A SORTED ARRAYAND A SUM WE NEED TO FIND IF THERE IS A PAIR WITH A GIVEN SUM:
I/P: 2,5,8,12,30
X = 17
PAIR: 5,12

Two pointer approach is bettter for sorted arrays since it takes O(n) time and O(1) extra space.
But if the array is unsorted then it should be done by using hashing which takes O(n) time with O(n) extra space.

// C++ Program Illustrating Naive Approach to
// Find if There is a Pair in A[0..N-1] with Given Sum
// Using Two-pointers Technique

// Importing required libraries
#include <iostream>
#include <algorithm>

using namespace std;

// Two pointer technique based solution to find
// if there is a pair in A[0..N-1] with a given sum.
int isPairSum(int A[], int N, int X)
{
	// represents first pointer
	int i = 0;

	// represents second pointer
	int j = N - 1;

	while (i < j) {

		// If we find a pair
		if (A[i] + A[j] == X)
			return 1;

		// If sum of elements at current
		// pointers is less, we move towards
		// higher values by doing i++
		else if (A[i] + A[j] < X)
			i++;

		// If sum of elements at current
		// pointers is more, we move towards
		// lower values by doing j--
		else
			j--;
	}
	return 0;
}

// Driver code
int main()
{
	// array declaration
	int arr[] = { 2, 3, 5, 8, 9, 10, 11 };
	
	// value to search
	int val = 17;
	
	// size of the array
	int arrSize = *(&arr + 1) - arr;
	
	// array should be sorted before using two-pointer technique
	sort(arr, arr+7);
	
	// Function call
	cout << (bool)isPairSum(arr, arrSize, val);

	return 0;
}


 Given a sorted array, we need to find a pair where the sum is K.
 
 I/p; 2,4,8,9,11,12,20,30
 O/P: true => 11+12 = 23.
 Using two pointer algorithm.
 bool isPair(int arrp[], int n, int x){
	int left = 0, right = n-1;
	while(left<right){
		if(arr[left]+arr[right] == x)
			return true;
		else if(arr[left]+arr[right]>x
			right--;
		else
			left++;
	}
	return false;
 }
 
 Another variation of the problem:
 
 Given a sorted array and a sum, find if there is a triplet with given sum.
 
 I/P: 2, 3,4,8,9,20,40
 X = 32
 O/P: yes 4+8+20
 
 Efficient approcah is
 bool find3Numbers(int A[], int arr_size, int sum) 
{ 
	int l, r; 

	/* Sort the elements */
	sort(A, A + arr_size); 

	/* Now fix the first element one by one and find the 
	other two elements */
	for (int i = 0; i < arr_size - 2; i++) { 

		// To find the other two elements, start two index 
		// variables from two corners of the array and move 
		// them toward each other 
		l = i + 1; // index of the first element in the 
		// remaining elements 

		r = arr_size - 1; // index of the last element 
		while (l < r) { 
			if (A[i] + A[l] + A[r] == sum) { 
				printf("Triplet is %d, %d, %d", A[i], 
					A[l], A[r]); 
				return true; 
			} 
			else if (A[i] + A[l] + A[r] < sum) 
				l++; 
			else // A[i] + A[l] + A[r] > sum 
				r--; 
		} 
	} 

	// If we reach here, then no triplet was found 
	return false; 
} 

ANOTHER DIFFERENT VARIATION OF THIS THREE POINTER APPROACH:
Count triplets with sum smaller than X
MediumAccuracy: 49.96%Submissions: 42619Points: 4
Given an array arr[] of distinct integers of size N and a value sum, the task is to find the count of triplets (i, j, k), having (i<j<k) with the sum of (arr[i] + arr[j] + arr[k]) smaller than the given value sum.

Example 1:

Input: N = 4, sum = 2
arr[] = {-2, 0, 1, 3}
Output:  2
Explanation: Below are triplets with 
sum less than 2 (-2, 0, 1) and (-2, 0, 3). 

long long countTriplets(long long arr[], int n, long long sum)
	{
	    // Your code goes here
	    sort(arr,arr+n);
	    long count = 0;
	    for(int i=0;i<n-2;i++){
	        long l = i+1,r = n-1;
	        while(l<r){
	            if(arr[i]+arr[l]+arr[r]<sum){
	                count = count+(r-l); // this is an important difference between before problems and this problem. If we already find a minimum sum value
	                l++;		    // then definitely the sum of smaller numbers less than r is also less than the given sum
	            }			    // eg: in 5,1,3,4,7 and the i = 0, l = 1, r = 4 , sum = 14, count = 0
	            else r--;		             if 5+1+7 = 13<14 then all the sum of smaller values less than 7 will be less than 14 right?
	            		             so count = count+(4-1) = 3 like this we can directly calculate the count in one go. which is easier and clever.
	    }
	    return count;
	}

 
--------------------------------------------------------------------------------
PROGRAM TO MOVE ALL ZEROES TO THE END OF THE ARRAY:

	Void moveZeroes(int arr[], int n)
	{
		int count = 0;
		for(int i=0;i<n;i++)
		{
			if(arr[i]!=0)
			{
				swap(arr[i],arr[count]);
				count++;
			}
		}
		
	}

-----------------------------------------------------------------------------------
LEFT ROTATE AN ARRAY BY ONE PLACE:

	void lRotateOne(int arr[], int n)
		{
			int temp = arr[0];

			for(int i = 1; i < n; i++)
			{
				arr[i - 1] = arr[i];
			}

			arr[n - 1] = temp;
		}
		
		or we can use swap function to swap every ith element with i+1 element till n-1 iteration in for loop.
		
	LEFT ROTATE AN ARRAY BY D PLACES:
	
#include <iostream>
#include <cmath>
using namespace std;


void reverse(int arr[], int low, int high)
{
	while(low < high)
	{
		swap(arr[high], arr[low]);

		low++;
		high--;
	}
}   

void leftRotate(int arr[], int d, int n)
{
	reverse(arr, 0, d - 1);

	reverse(arr, d, n - 1);

	reverse(arr, 0, n - 1);
}



int main() {
	
      int arr[] = {1, 2, 3, 4, 5}, n = 5, d = 2;

      cout<<"Before Rotation"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }

       cout<<endl;

       leftRotate(arr, d, n);

       cout<<"After Rotation"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }
    
}
-----------------------------------------------------------------------------------------
LEADERS IN AN ARRAY
	I/P: arr[] = {7,10,4,3,6,5,2}
	o/p: 10,6,5,2
	leaders of an array means the current element is greater than all the elements
	to its right of the array. Even if there is an element which is same value as the current,
	it is not considered as leader.
An efficient approach is to traverse from the right side of the array,
the last element is always the leader of the array. so we keep checking from the right side with the 
current leader if it is greater we print the current leader. we repeat the process by changinh the leader everytime 
we find the new leader and checks them and print it if is greater.
	void leaders(int arr[], int n)
		{
			int curr_ldr = arr[n - 1];

			cout<<curr_ldr<<" ";

			for(int i = n - 2; i >= 0; i--)
			{
				if(curr_ldr < arr[i])
				{
					curr_ldr = arr[i];

					cout<<curr_ldr<<" ";
				}
			}
		}
-----------------------------------------------------------------------------------------------------------------------------
MAXIMUM DIFFERENCE PROBLEM WITH ORDER

Maximum Difference problem is to find the maximum of arr[j] - arr[i] where j>i.
	int maxDiff(int arr[], int n)
		{
			int res = arr[1] - arr[0], minVal = arr[0];

			for(int i = 1; i < n; i++)
			{
				
					res = max(res, arr[i] - minVal);
					
					minVal = min(minVal, arr[i]);
			}

			return res;
		}
		approach is to keep tracking of min value in every iterationa and checks with the current difference.
-----------------------------------------------------------------------------------------------
FREQUENCIES IN A SORTED ARRAY


		void printFreq(int arr[], int n)
			{
				int freq = 1, i = 1;

				while(i < n)
				{
					while(i < n && arr[i] == arr[i - 1])
					{
						freq++;
						i++;
					}

					cout<<arr[i - 1] << " " << freq << endl;

					i++;
					freq = 1;
				}
			}
-------------------------------------------------------------------------------------------------------------
TRAPPING RAIN WATER:


int getWater(int arr[], int n)
	{
		int res = 0;

		for(int i = 1; i < n - 1; i++)
		{
			int res = 0;

			int lMax[n];
			int rMax[n];

			lMax[0] = arr[0];
			for(int i = 1; i < n; i++)
				lMax[i] = max(arr[i], lMax[i - 1]);


			rMax[n - 1] = arr[n - 1];
			for(int i = n - 2; i >= 0; i--)
				rMax[i] = max(arr[i], rMax[i + 1]);

			for(int i = 1; i < n - 1; i++)
				res = res + (min(lMax[i], rMax[i]) - arr[i]);
			
			return res;
		}
		return res;
	}
-----------------------------------------------------------------------------------------------------------------------

STOCK BUY AND SELL:

#include <iostream>
#include <cmath>
using namespace std;


int maxProfit(int price[], int n)
{
	int profit = 0;

	for(int i = 1; i < n; i++)
	{
		if(price[i] > price[i - 1])
			profit += price[i] - price[i -1];
	}

	return profit;

}


int main() {
	
      int arr[] = {1, 5, 3, 8, 12}, n = 5;

      cout<<maxProfit(arr, n);
    
}
-------------------------------------------------------------------------------------------------------------------------
MAXIMUM CONSECUTIVE 1'S IN A BINARY ARRAY.
two methods with same time complexity but different logics.
int maxConsecutiveOnes(int arr[], int n)
{
	int res = 0, curr = 0;

	for(int i = 0; i < n; i++)
	{
		if(arr[i] == 0)
			curr = 0;
		else
		{
			curr++;

			res = max(res, curr);
		}
	}
	
	return res;
}

By BIT MAGIC:
int maxConsecutiveOnes(int n)
    {
        // code here
        int count = 0, max = 0;
        while(n>0){
            if(n&1) count++;
            else count = 0;
            if(count>max) max = count;
            n = n>>1;
        }
        return max;
    }
-----------------------------------------------------------------------------
MAXIMUM SUM SUB ARRAY: 


										KADANE’S ALGORITHM:
										
										

{-5, 1, -2, 3, -1, 2, -2}

the efficient approach here is to find the max sub array sum for every ith index 
by adding the previous maxending(i) with the current index and compares it and
chnages the maxending() if it is greater than the current.

maxEnding(i) = max(maxEnding(i-1)+arr[i], arr[i])

{-5, 1, -2, 3, -1, 2, -2}
-5 = -5, maxending = -5
1 = 1+(-5) = -4 = max(-4,1) = 1
-2 = -2+1 = -1 = max(-1, -2) = -1
3  = 3+-1 = 2 = max(2,3) = 3

#include <iostream>
#include <cmath>
using namespace std;


int maxSum(int arr[], int n)
{
	int res = arr[0];

	int maxEnding = arr[0];

	for(int i = 1; i < n; i++)
	{
		maxEnding = max(maxEnding + arr[i], arr[i]);

		res = max(maxEnding, res);
	}
	
	return res;
}



int main() {
	
     int arr[] = {1, -2, 3, -1, 2}, n = 5;

     cout<<maxSum(arr, n);
    
}

-----------------------------------------------------------------------------
LONGEST EVEN ODD SUB ARRAY

#include <iostream>
#include <cmath>
using namespace std;


int maxEvenOdd(int arr[], int n)
{
	int res = 1;
	int curr = 1;

	for(int i = 1; i < n; i++)
	{
			if((arr[i] % 2 == 0 && arr[i - 1] % 2 != 0)
			   ||(arr[i] % 2 != 0 && arr[i - 1] % 2 == 0))
				{
					curr++;

					res = max(res, curr);
				}
				else
					curr = 1;
	}
	
	return res;
}



int main() {
	
     int arr[] = {5, 10, 20, 6, 3, 8}, n = 6;

     cout<<maxEvenOdd(arr, n);
    
}
-------------------------------------------------------------------------------------------
MAXIMUM CIRCULAR SUM SUBARRAY:

	Our approach si to find the normaal subarray max by kadanes algorithm and then find the minimum sub array by kadanes algorithm and then add the minimum sub array to max subarray
	which gives the circular sub array. Finally we compare both normal sub array sum and circular sub array sum and prints the max.
	
	eg:
	 arr = {8,-4,3,-5,4}
			normal sub array sum = 8
			sum of the array = 8+(-4)+3+(-5)+4 = 6
			we invert the signs of the array to find min sub array by kadanes algorithm, instead of writing different func we just invert the signs
			 after inverting the signs we have -8,4,-3,5,-4 
												max sub array of this array is: 4+(-3)+5 = 6
												circular sub array sum = sum+min sub array = 6+6 = 12
										max(normalsub array sum, circular sub array sum) = max(8,12) = 12
												  

The task is to find maximum circular sum subarray of a given array.  
#include <iostream>
#include <cmath>
using namespace std;


int normalMaxSum(int arr[], int n)
{
	int res = arr[0];

	int maxEnding = arr[0];

	for(int i = 1; i < n; i++)
	{
		maxEnding = max(maxEnding + arr[i], arr[i]);

		res = max(maxEnding, res);
	}
	
	return res;
}

int overallMaxSum(int arr[], int n)
{
	int max_normal = normalMaxSum(arr, n);

	if(max_normal < 0)
		return max_normal;

	int arr_sum = 0;

	for(int i = 0; i < n; i++)
	{
		arr_sum += arr[i];

		arr[i] = -arr[i];
	}

	int max_circular = arr_sum + normalMaxSum(arr, n);

	return max(max_circular, max_normal);
}



int main() {
	
     int arr[] = {8, -4, 3, -5, 4}, n = 5;

     cout<<overallMaxSum(arr, n);
    
}
-----------------------------------------------------------------------------------------------------------

Majority Element
Majority element is an element that appears more than n/2 times in an array of size n. In this video, two methods to find majority element in an array are discussed.


Check out the video for better understanding:

int findMajority(int arr[], int n)
{
	int res = 0, count = 1;

    	for(int i = 1; i < n; i++)
    	{
    		if(arr[res] == arr[i])
    			count++;
    		else 
    			count --;

    		if(count == 0)
    		{
    			res = i; count = 1;
    		}
    	}

    	count = 0;

    	for(int i = 0; i < n; i++)
    		if(arr[res] == arr[i])
    			count++;

    	if(count <= n /2)
    		res = -1;

    	return res; 
}
----------------------------------------------------------------------------------------------------------------------

Minimum Consecutive Flips
Given a binary array, we need to find the minimum of number of group flips to make all array elements same. 
 In a group flip, we can flip any set of consecutive 1s or 0s.
 
 In every binary representation there is always equal or 1 less number of 1's(or) 0's groups.
 And the second occuring group is always has less groups or equal groups.
 
 void printGroups(int arr[], int n)
{
	for(int i = 1; i < n; i++)
	{
		if(arr[i] != arr[i - 1])
		{
			if(arr[i] != arr[0])
                cout << "From " << i << " to ";
			else
                cout << i - 1 << endl;
		}
	}

	if(arr[n - 1] != arr[0])
        cout << n - 1 << endl;
}

-------------------------------------------------------------------------------------------------------------------------
SLIDING WINDOW TECHNIQUE
GIVEN AN ARRAY OF INTEGERS AND A NUMBER K, FIND THE MAXIMUM SUM OF K CONSECUTIVE ELEMENTS. (CONTIGOUS ELEMENTS)


I/P:  1,8,30,-5,20,7
K = 3
1+8+30 = 39
8+30-5 = 33
30-5+20 = 45
-5+20+7 = 22
MAX SUB ARRAY WITH K CONSECUTIVE ELEMENTS.
O/P: 45 ()

int maxSum(int arr[], int n, int k)
{
	int curr_sum = 0;

	for(int i = 0; i < k; i++)
		curr_sum += arr[i];

	int max_sum = curr_sum;

	for(int i = k; i < n; i++)
	{
		curr_sum += (arr[i] - arr[i - k]);

		max_sum = max(max_sum, curr_sum);
	}
	return max_sum;
}

another approach:
vector<int> subarraySum(int arr[], int n, long long s)
    {
        // Your code here
        
        long long sum = 0;
        int l=0, r=0;
        
        for(int i=0; i<n; i++){
            sum += arr[i];
            r++;
            
            if(sum > s){
                while(sum > s and r>l){
                    sum -= arr[l];
                    l++;
                }
            }
            if(sum == s and l!=r){
                return {l+1, r};
            }
        }
        
        return {-1};
    }

Variation of the problem:

FIND SUBARRAY WITH GIVEN SUM: Given and unsorted array of non negative integers. Find if there is a sub array with given sum.(CONTIGOUS ElementS ONLYTWO)
	
/* An efficient program to print subarray with sum as given sum */
#include<stdio.h> 

/* Returns true if the there is a subarray of arr[] with a sum equal to 'sum' 
otherwise returns false. Also, prints the result */
int subArraySum(int arr[], int n, int sum) 
{ 
	/* Initialize curr_sum as value of first element 
	and starting point as 0 */
	int curr_sum = arr[0], start = 0, i; 

	/* Add elements one by one to curr_sum and if the curr_sum exceeds the 
	sum, then remove starting element */
	for (i = 1; i <= n; i++) 
	{ 
		// If curr_sum exceeds the sum, then remove the starting elements 
		while (curr_sum > sum && start < i-1) 
		{ 
			curr_sum = curr_sum - arr[start]; 
			start++; 
		} 

		// If curr_sum becomes equal to sum, then return true 
		if (curr_sum == sum) 
		{ 
			printf ("Sum found between indexes %d and %d", start, i-1); 
			return 1; 
		} 

		// Add this element to curr_sum 
		if (i < n) 
		curr_sum = curr_sum + arr[i]; 
	} 

	// If we reach here, then no subarray 
	printf("No subarray found"); 
	return 0; 
} 

// Driver program to test above function 
int main() 
{ 
	int arr[] = {15, 2, 4, 8, 9, 5, 10, 23}; 
	int n = sizeof(arr)/sizeof(arr[0]); 
	int sum = 23; 
	subArraySum(arr, n, sum); 
	return 0; 
} 

Another variation:

		N-BONACCI NUMBERS	
		void bonacciseries(long n, int m) 
{ 

	// Assuming m > n. 
	int a[m] = { 0 }; 
	a[n - 1] = 1; 
	a[n] = 1; 

	// Uses sliding window 
	for (int i = n + 1; i < m; i++) 
		a[i] = 2 * a[i - 1] - a[i - n - 1]; 

	// Printing result 
	for (int i = 0; i < m; i++) 
		cout << a[i] << " "; 
} 
----------------------------------------------------------------------------------------------------------------------
PREFIX SUM ARRAY:

#include <iostream>
#include <cmath>
#include <climits>
using namespace std;


int prefix_sum[10000]; 

void preSum(int arr[], int n)
{


	prefix_sum[0] = arr[0];

	for(int i = 1; i < n; i++)
	{
		prefix_sum[i] = prefix_sum[i - 1] + arr[i];
	}
	
	
}

int getSum(int prefix_sum[], int l, int r)
{
	if(l != 0)
		return prefix_sum[r] - prefix_sum[l - 1];
	else
		return prefix_sum[r];
}
    


int main() {
	
      int arr[] = {2, 8, 3, 9, 6, 5, 4}, n = 7;

      preSum(arr, n);

     cout<<getSum(prefix_sum, 1, 3)<<endl;
     
     cout<<getSum(prefix_sum, 0, 2)<<endl;
    
}

Variation of the prefix sum: equilibrium point.
bool checkEquilibrium(int arr[], int n)
{
	int sum = 0;

	for(int i = 0; i < n; i++)
	{
		sum += arr[i];
	}

	int l_sum = 0;

	for(int i = 0; i < n; i++)
	{
		if(l_sum == sum - arr[i])
			return true;

		l_sum += arr[i];

		sum -= arr[i];
	}

	return false;
}

Another variation:
	MAXIMUM OCCURING ELEMENT.
	I/P: L[] = {1,2,5,15}
	     R[] = {5,8,7,18}
		 
		 O/P: 5

	
	
	
	
	
	
	
	
	
	
	
====================================================================================================================================================================================
	
============================================================================================================================================================================
----------------------------------------------------------------------------

IMPORTANT PROBLEM FOR REFERENCE:
 EQUILIBRIUM POINT:
 Input: 
n = 5 
A[] = {1,3,5,2,2} 
Output: 3 
Explanation: For second test case 
equilibrium point is at position 3 
as elements before it (1+3) = 
elements after it (2+2).

int equilibriumPoint(long long a[], int n) {
    
        // Your code here
        int sum = 0, lsum = 0;
        for(int i=0;i<n;i++) sum+= a[i];
        for(int i=0;i<n;i++){
            if(lsum == sum-a[i]) return i+1;
            lsum+= a[i];
            sum-= a[i];
        }
        return -1;
    }
-----------------------------------------------------------------------------------------
Frequencies of Limited Range Array Elements
Input:
N = 5
arr[] = {2, 3, 2, 3, 5}
P = 5
Output:
0 2 2 0 1
Explanation: 
Counting frequencies of each array element
We have:
1 occurring 0 times.
2 occurring 2 times.
3 occurring 2 times.
4 occurring 0 times.
5 occurring 1 time.

void frequencyCount(vector<int>& arr,int N, int P)
    { 
        // code here
        vector<int> v(N+1,0);
        for(int i=0;i<N;i++){
            if(arr[i]<=N && arr[i]>0){
                v[arr[i]]++;
            }
        }
        for(int i=1;i<N+1;i++){
            arr[i-1] = v[i];
        }
        
    }
----------------------------------------------------------------------------------------------------
You are given an array arr[] of N integers including 0. The task is to find the smallest positive number missing from the array.

Example 1:

Input:
N = 5
arr[] = {1,2,3,4,5}
Output: 6
Explanation: Smallest positive missing 
number is 6.
Example 2:

Input:
N = 5
arr[] = {0,-10,1,3,-20}
Output: 2
Explanation: Smallest positive missing 
number is 2.

There are two solutions: a simplem solution with more time:


easiest way to do this is as follows:

 

int missingNumber(int arr[], int n) 
   { 
      
       sort(arr,arr+n);
       int count=1;
       for (int i=0;i<n;i++)
       {
           if (arr[i]==count)
           count++;
       }
       return count;
   } 

Less time taking and lengthy process:

int segregateArr (int arr[], int n) 
    { 
    	int j = 0; 
    	for(int i = 0; i < n; i++) 
    	{ 
    	    if(arr[i] <= 0) 
    	    { 
    	        //changing the position of negative numbers and 0.
    	        swap(arr[i], arr[j]); 
    	        //incrementing count of non-positive integers.
    	        j++; 
    		} 
    	}
    	return j; 
    } 
    
    //Finding the smallest positive missing number in an array 
    //that contains only positive integers.
    int findMissingPositive(int arr[], int n)
    {
        
        //marking arr[i] as visited by making arr[arr[i]-1] negative. 
        //note that 1 is subtracted because indexing starts from 0 and 
        //positive numbers start from 1.
        for(int i=0; i<n; i++) 
        {
    	    if(abs(arr[i]) - 1 < n && arr[ abs(arr[i]) - 1] > 0) 
    	    arr[ abs(arr[i]) - 1] = -arr[ abs(arr[i]) - 1]; 
        } 
        
        for(int i=0; i<n; i++)
        {
            if (arr[i] > 0)
            {
                //returning the first index where value is positive. 
                // 1 is added because indexing starts from 0. 
    	        return i+1; 
            }
        }
        return n+1; 
    } 
    
    //Function to find the smallest positive number missing from the array.
    int missingNumber(int arr[], int n) 
    { 
        //first separating positive and negative numbers. 
        int shift = segregateArr(arr, n); 
        
        //shifting the array to access only positive part.
        //calling function to find result and returning it.
        return findMissingPositive(arr+shift, n-shift); 
    } 
----------------------------------------------------------------------------------------------------------------------------------
REARRANGE ARRAY ALTERNATIVELY:
	
Input:
N = 6
arr[] = {1,2,3,4,5,6}
Output: 6 1 5 2 4 3
Explanation: Max element = 6, min = 1, 
second max = 5, second min = 2, and 
so on... Modified array is : 6 1 5 2 4 3.


														DIVIDENT = DIVISOR*QUOTIENT+REMINDER
																divident = modified value in array.							// can store two values at same index
																divisor = max element of array+1
																quotient: new value to be stored
																reminder: original value.
																
																we get the original value by taking modulus of max+1 element.
																we get old value by taking floor value after dividing with max+1 element.
														eg: 1 2 3 4 5 6  // max = 6 max+1 = 6+1 = 7
															index 0 = old value = 1
																	  new value to be placed = 6
																	7*6+1 = 43 is value at index 0 now.
																	if we want new value, divide it by max+1 element = 43/7 = 6
																	if we want old value do modulus = 43%7 = 1.
															
eg: 1 2 3 4 5 6
	6 1 5 2 4 3


void rearrange(long long *arr, int n) 
    { 
    	
    	// Your code here
    	//Initialising index of first minimum and first maximum element. 
    	int max_idx = n - 1, min_idx = 0; 
    
    	//Storing maximum element of array. 
    	int max_elem = arr[n - 1] + 1; 
    
    	for (int i = 0; i < n; i++) { 
    		//At even index, we have to put maximum elements in decreasing order. 
    		if (i % 2 == 0) { 
    			arr[i] += (arr[max_idx] % max_elem) * max_elem; 
				// IMP: The reason we are doing modulus before multiplying is we might have elements that are already modified,
				so when we do modulus we get original value in that so we do modulus. eg: at 1th index we need 1(0th index) which is original value but
				since the value at 0th index is already modified and now has 43 value we do modulus and take the reminder which "1" is oroiginal value
				similarly we continue the process.
																		
				//Updating maximum index.
    			max_idx--; 
    		} 
    
    		//At odd index, we have to put minimum elements in increasing order. 
    		else { 
    			arr[i] += (arr[min_idx] % max_elem) * max_elem;
    			//Updating minimum index.
    			min_idx++; 
    		} 
    	} 
    
    	//Dividing array elements by maximum element to get the result. 
    	for (int i = 0; i < n; i++) 
    		arr[i] = arr[i] / max_elem;
    	
    	
    	
    	 
    }

Different variation of the problem:
Given an array arr[] of size N where every element is in the range from 0 to n-1. Rearrange the given array so that arr[i] becomes arr[arr[i]].

 Input:
N = 5
arr[] = {4,0,2,1,3}
Output: 3 4 2 0 1
Explanation: 
arr[arr[0]] = arr[4] = 3.
arr[arr[1]] = arr[0] = 4.
and so on.

void arrange(long long arr[], int n) {
        // Your code here
        int max = n;
        for(int i=0;i<n;i++){
            arr[i]+= (arr[arr[i]]%max)*max;
        }
        for(int i=0;i<n;i++)
        arr[i]/= max;
        
        
    }
-----------------------------------------------------------------------------------------------------
FINDING DUPLICATES IN AN ARRAY:
Given an array a[] of size N which contains elements from 0 to N-1, you need to find all 
the elements occurring more than once in the given array.

Input:
N = 5
a[] = {2,3,1,2,3}
Output: 2 3 
Explanation: 2 and 3 occur more than once
in the given array.

 vector<int> duplicates(int arr[], int n) {
        // First check all the values that are
        // present in an array then go to that
        // values as indexes and increment by
        // the size of array
        for (int i = 0; i < n; i++) {
            int index = arr[i] % n;
            arr[index] += n;
        }
    
        // Now check which value exists more
        // than once by dividing with the size
        // of array
        bool flag = false;
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if ((arr[i] / n) > 1) {
                ans.push_back(i);
                flag = true;
            }
        }
        if (!flag) ans.push_back(-1);
        return ans;
    }


-----------------------------------------------------------------------------------------------------------------
FIND MISSING AND REPEATING:

Given an unsorted array Arr of size N of positive integers. One number 'A' from set {1, 2, …N} is missing and one number 'B' occurs twice in array.
 Find these two numbers.

Example 1:

Input:
N = 2
Arr[] = {2, 2}
Output: 2 1
Explanation: Repeating number is 2 and 
smallest positive missing number is 1.

I/P: 5 3 2 4 2
O/P: 2 1 (2 is repeating and 1 is missing)
#include <bits/stdc++.h>

using namespace std;

// } Driver Code Ends
class Solution{
public:
    int *findTwoElement(int *arr, int n) {
        // code here
        int* res = new int(2);
        //res[0] = 0;
        //res[1] = 0;
        for(int i=0;i<n;i++){
            if(arr[abs(arr[i])-1]<0)
            res[0] = abs(arr[i]);
            else
                arr[abs(arr[i])-1]*= -1;
        }
        for(int i=0;i<n;i++){
            if(arr[i]>0){
                //cout<<i<<endl;
                //res[0] = arr[i];
                res[1] = i+1;
                break;
            }
        }
        
        return res;
    }
};

//{ Driver Code Starts.

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int a[n];
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        Solution ob;
        auto ans = ob.findTwoElement(a, n);
        cout << ans[0] << " " << ans[1] << "\n";
    }
    return 0;
}
// } Driver Code Ends

When asked about finding repeating elemenst questions, We can use arr[abs(arr[i])-1] technique when the output can be unsorted way and also in a manner where the numbers appears twice first will be printed first.
eg: I/P: 1 2 1 3 4 3
    O/P: 1,3
    
vector<int> duplicates(int arr[], int n) {
        // code here
       vector<int> res;
       bool flag = false;
        for(int i=0;i<n;i++){
            if(arr[abs(arr[i])-1]<0){        // or we can directly give if(arr[abs(arr[i])]<0) => when the input is from 0-N
                res.push_back(abs(arr[i]));
                flag = true;
            } 
            else
            arr[abs(arr[i])-1]*= -1;         // or arr[abs(arr[i])]*= -1;    => when the inout is from 0-N
            
        }
        if(flag == false) res.push_back(-1);
        return res;
    }


When the output should be printed in sorted manner then we should use the below logic. This will print the duplicates values in a sorted manner.

 vector<int> duplicates(int arr[], int n) {
        // First check all the values that are
        // present in an array then go to that
        // values as indexes and increment by
        // the size of array
        for (int i = 0; i < n; i++) {
            int index = arr[i] % n;
            arr[index] += n;
        }
    
        // Now check which value exists more
        // than once by dividing with the size
        // of array
        bool flag = false;
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if ((arr[i] / n) > 1) {
                ans.push_back(i);
                flag = true;
            }
        }
        if (!flag) ans.push_back(-1);
        return ans;
    }
-------------------------------------------------------------------------------------------------------------------
problem where both two pointer and sliding window technique is used:

Given an array arr of n positive integers and a number k. One can apply a swap operation on the array any number of times,
 i.e choose any two index i and j (i < j) and swap arr[i] , 
arr[j] . Find the minimum number of swaps required to bring all the numbers less than or equal to k together, i.e. make them a contiguous subarray.

arr[ ] = {2, 1, 5, 6, 3} 
K = 3
Output : 
1
Explanation:
To bring elements 2, 1, 3 together,
swap index 2 with 4 (0-based indexing),
i.e. element arr[2] = 5 with arr[4] = 3
such that final array will be- 
arr[] = {2, 1, 3, 6, 5}

//{ Driver Code Starts
// C++ program to find minimum swaps required
// to club all elements less than or equals
// to k together
#include <bits/stdc++.h>
using namespace std;



// } Driver Code Ends


class Solution
{
public:
    int minSwap(int arr[], int n, int k) {
        // Complet the function
        // Find count of elements which are
        // less than equals to k
        int count = 0;
        for (int i = 0; i < n; ++i)
            if (arr[i] <= k)
                ++count;

        // Find unwanted elements in current
        // window of size 'count'
        int bad = 0;
        for (int i = 0; i < count; ++i)
            if (arr[i] > k)
                ++bad;

        // Initialize answer with 'bad' value of
        // current window
        int ans = bad;
        for (int i = 0, j = count; j < n; ++i, ++j) {

            // Decrement count of previous window
            if (arr[i] > k)
                --bad;

            // Increment count of current window
            if (arr[j] > k)
                ++bad;

            // Update ans if count of 'bad'
            // is less in current window
            ans = min(ans, bad);
        }
        return ans;
        
    }
};


//{ Driver Code Starts.

// Driver code
int main() {

	int t,n,k;
	cin>>t;
	while(t--)
    {
        cin>>n;
        int arr[n];
        for(int i=0;i<n;i++)
            cin>>arr[i];
        cin>>k;
        Solution ob;
        cout << ob.minSwap(arr, n, k) << "\n";
    }
	return 0;
}

// } Driver Code Ends

--------------------------------------------------------------------------------------------------------------------------------------------------
IMPORTANT TWO POINTER PROBLEM:(ALSO CAN BE DONE BY SLIDING WINDOW)

Given an array of integers (A[])  and a number x, find the smallest subarray with sum greater than the given value.

Note: The answer always exists. It is guaranteed that x doesn't exceed the summation of a[i] (from 1 to N).

Example 1:

Input:
A[] = {1, 4, 45, 6, 0, 19}
x  =  51
Output: 3
Explanation:
Minimum length subarray is 
{4, 45, 6}

int smallestSubWithSum(int arr[], int n, int x)
    {
        // Your code goes here   
        int sum = 0, res = INT_MAX;
        int l = 0, h = 0;
        while(h<n){
            sum+=arr[h];
            if(arr[h]>x) return 1;
            if(sum>x){
                while(sum>x){
                    res = min(res,(h-l+1));  //always remember where we are keeping the final result value, if we keep this res after l++, the whole problem changes.
                    sum-=arr[l];
                    l++;
                }
            }
            h++; // same as res at line 1475, if we keep this h++ in the beginning of the problem the whole function will takes already incremented value. so be 
            	 // careful where we keep some lines of logics.
        }
        return res;
    }
