         --------------------------- ARRAYS DATA STRUCTURE  ----------------------------------------------
 
 VECTORS IN C++:
	ADVANATGES OF VECTORS IN C++:
		- dynamic size
		-rich library functions find,erase, insert etc..
		-easy to know the size
		-no need to pass size
		-can be returned from a functions
		-by default initialized with default values
		- we can copy a vector to other easily, v1=v2 copies all elements of v2 to v1

-------------------------------------------------------

OPERATION ON ARRAYS:
	Searching an element in an array and returns its index position.
	
	In unsorted array: O(n) time complexity.
	int search(int arr[], int n, int x)
		{
			for(int i = 0; i < n; i++)
			{
				if(arr[i] == x)
					return i;
			}

			return -1;
		}
		
	Inserting an element in an array only there is extra space in the array.
	int insert(int arr[], int n, int x, int cap, int pos)
		{
			if(n == cap)
				return n;

			int idx = pos - 1;

			for(int i = n - 1; i >= idx; i--)
			{
				arr[i + 1] = arr[i];
			}

			arr[idx] = x;

			return n + 1;
		} 
	Deletion of an element in an array
	int deleteEle(int arr[], int n, int x)
		{
			int i = 0;

			for(i = 0; i < n; i++)
			{
				if(arr[i] == x)
					break;
			}

			if(i == n)
				return n;

			for(int j = i; j < n - 1; j++)
			{
				arr[j] = arr[j + 1];
			}

			return n-1;
		} 
TIME COMPLEXITIES OF ALL OPERATIONS:
	Insert: O(n)
	Search: O(n) for unsorted
			O(logn) for sorted
	Delete: O(n)
	Getting ith element & updating ith element:  O(1)
--------------------------------------------------------------------

LARGEST ELEMENT IN AN ARRAY:
--------------------------------------------------------------------

CHECK IF AN ARRAY IS SORTED OR NOT:

#include <iostream>
#include <cmath>
using namespace std;

bool isSorted(int arr[], int n)
{
	for(int i = 1; i < n; i++)
	{
	    if(arr[i] < arr[i - 1])
	        return false;
	}

	return true;
} 

    
int main() {
	
      int arr[] = {5, 12, 30, 2, 35}, n = 5;
      
      printf("%s", isSorted(arr, n)? "true": "false");
    
}
---------------------------------------------------------------------
REVERSE OF AN ARRAY:

#include <iostream>
#include <cmath>
using namespace std;

 void reverse(int arr[], int n)
{
	int low = 0, high = n - 1;

	while(low < high)
	{
		int temp = arr[low];

		arr[low] = arr[high];

		arr[high] = temp;

		low++;
		high--;
	}
}

    
int main() {
	
      int arr[] = {10, 5, 7, 30}, n = 4;

      cout<<"Before Reverse"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }

       cout<<endl;

       reverse(arr, n);

       cout<<"After Reverse"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }
    
}
-----------------------------------------------------------------------
REMOVE DUPLICATES FROMTHE SORTED ARRAY:

int remDups(int arr[], int n)
	{
		int res = 1;

		for(int i = 1; i < n; i++)
		{
			if(arr[res - 1] != arr[i])
			{
				arr[res] = arr[i];
				res++;
			}
		}

		return res;
	}
--------------------------------------------------------------------------------
PROGRAM TO MOVE ALL ZEROES TO THE END OF THE ARRAY:

	Void moveZeroes(int arr[], int n)
	{
		int count = 0;
		for(int i=0;i<n;i++)
		{
			if(arr[i]!=0)
			{
				swap(arr[i],arr[count]);
				count++;
			}
		}
		
	}

-----------------------------------------------------------------------------------
LEFT ROTATE AN ARRAY BY ONE PLACE:

	void lRotateOne(int arr[], int n)
		{
			int temp = arr[0];

			for(int i = 1; i < n; i++)
			{
				arr[i - 1] = arr[i];
			}

			arr[n - 1] = temp;
		}
		
		or we can use swap function to swap every ith element with i+1 element till n-1 iteration in for loop.
		
	LEFT ROTATE AN ARRAY BY D PLACES:
	
#include <iostream>
#include <cmath>
using namespace std;


void reverse(int arr[], int low, int high)
{
	while(low < high)
	{
		swap(arr[high], arr[low]);

		low++;
		high--;
	}
}   

void leftRotate(int arr[], int d, int n)
{
	reverse(arr, 0, d - 1);

	reverse(arr, d, n - 1);

	reverse(arr, 0, n - 1);
}



int main() {
	
      int arr[] = {1, 2, 3, 4, 5}, n = 5, d = 2;

      cout<<"Before Rotation"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }

       cout<<endl;

       leftRotate(arr, d, n);

       cout<<"After Rotation"<<endl;

       for(int i = 0; i < n; i++)
       {
       		cout<<arr[i]<<" ";
       }
    
}
-----------------------------------------------------------------------------------------
LEADERS IN AN ARRAY
	I/P: arr[] = {7,10,4,3,6,5,2}
	o/p: 10,6,5,2
	leaders of an array means the current element is greater than all the elements
	to its right of the array. Even if there is an element which is same value as the current,
	it is not considered as leader.
An efficient approach is to traverse from the right side of the array,
the last element is always the leader of the array. so we keep checking from the right side with the 
current leader if it is greater we print the current leader. we repeat the process by changinh the leader everytime 
we find the new leader and checks them and print it if is greater.
	void leaders(int arr[], int n)
		{
			int curr_ldr = arr[n - 1];

			cout<<curr_ldr<<" ";

			for(int i = n - 2; i >= 0; i--)
			{
				if(curr_ldr < arr[i])
				{
					curr_ldr = arr[i];

					cout<<curr_ldr<<" ";
				}
			}
		}
-----------------------------------------------------------------------------------------------------------------------------
MAXIMUM DIFFERENCE PROBLEM WITH ORDER

Maximum Difference problem is to find the maximum of arr[j] - arr[i] where j>i.
	int maxDiff(int arr[], int n)
		{
			int res = arr[1] - arr[0], minVal = arr[0];

			for(int i = 1; i < n; i++)
			{
				
					res = max(res, arr[i] - minVal);
					
					minVal = min(minVal, arr[i]);
			}

			return res;
		}
		approach is to keep tracking of min value in every iterationa and checks with the current difference.
-----------------------------------------------------------------------------------------------
FREQUENCIES IN A SORTED ARRAY


		void printFreq(int arr[], int n)
			{
				int freq = 1, i = 1;

				while(i < n)
				{
					while(i < n && arr[i] == arr[i - 1])
					{
						freq++;
						i++;
					}

					cout<<arr[i - 1] << " " << freq << endl;

					i++;
					freq = 1;
				}
			}
-------------------------------------------------------------------------------------------------------------
TRAPPING RAIN WATER:


int getWater(int arr[], int n)
	{
		int res = 0;

		for(int i = 1; i < n - 1; i++)
		{
			int res = 0;

			int lMax[n];
			int rMax[n];

			lMax[0] = arr[0];
			for(int i = 1; i < n; i++)
				lMax[i] = max(arr[i], lMax[i - 1]);


			rMax[n - 1] = arr[n - 1];
			for(int i = n - 2; i >= 0; i--)
				rMax[i] = max(arr[i], rMax[i + 1]);

			for(int i = 1; i < n - 1; i++)
				res = res + (min(lMax[i], rMax[i]) - arr[i]);
			
			return res;
		}
		return res;
	}
-----------------------------------------------------------------------------------------------------------------------

STOCK BUY AND SELL:
#include <iostream>
#include <cmath>
using namespace std;


int maxProfit(int price[], int n)
{
	int profit = 0;

	for(int i = 1; i < n; i++)
	{
		if(price[i] > price[i - 1])
			profit += price[i] - price[i -1];
	}

	return profit;

}


int main() {
	
      int arr[] = {1, 5, 3, 8, 12}, n = 5;

      cout<<maxProfit(arr, n);
    
}
-------------------------------------------------------------------------------------------------------------------------
MAXIMUM CONSECUTIVE 1'S IN A BINARY ARRAY.
two methods with same time complexity but different logics.
int maxConsecutiveOnes(int arr[], int n)
{
	int res = 0, curr = 0;

	for(int i = 0; i < n; i++)
	{
		if(arr[i] == 0)
			curr = 0;
		else
		{
			curr++;

			res = max(res, curr);
		}
	}
	
	return res;
}

By BIT MAGIC:
int maxConsecutiveOnes(int n)
    {
        // code here
        int count = 0, max = 0;
        while(n>0){
            if(n&1) count++;
            else count = 0;
            if(count>max) max = count;
            n = n>>1;
        }
        return max;
    }
-----------------------------------------------------------------------------
MAXIMUM SUM SUB ARRAY: 


										KADANEâ€™S ALGORITHM:
										
										

{-5, 1, -2, 3, -1, 2, -2}

the efficient approach here is to find the max sub array sum for every ith index 
by adding the previous maxending(i) with the current index and compares it and
chnages the maxending() if it is greater than the current.

maxEnding(i) = max(maxEnding(i-1)+arr[i], arr[i])

{-5, 1, -2, 3, -1, 2, -2}
-5 = -5, maxending = -5
1 = 1+(-5) = -4 = max(-4,1) = 1
-2 = -2+1 = -1 = max(-1, -2) = -1
3  = 3+-1 = 2 = max(2,3) = 3

#include <iostream>
#include <cmath>
using namespace std;


int maxSum(int arr[], int n)
{
	int res = arr[0];

	int maxEnding = arr[0];

	for(int i = 1; i < n; i++)
	{
		maxEnding = max(maxEnding + arr[i], arr[i]);

		res = max(maxEnding, res);
	}
	
	return res;
}



int main() {
	
     int arr[] = {1, -2, 3, -1, 2}, n = 5;

     cout<<maxSum(arr, n);
    
}

-----------------------------------------------------------------------------
LONGEST EVEN ODD SUB ARRAY

#include <iostream>
#include <cmath>
using namespace std;


int maxEvenOdd(int arr[], int n)
{
	int res = 1;
	int curr = 1;

	for(int i = 1; i < n; i++)
	{
			if((arr[i] % 2 == 0 && arr[i - 1] % 2 != 0)
			   ||(arr[i] % 2 != 0 && arr[i - 1] % 2 == 0))
				{
					curr++;

					res = max(res, curr);
				}
				else
					curr = 1;
	}
	
	return res;
}



int main() {
	
     int arr[] = {5, 10, 20, 6, 3, 8}, n = 6;

     cout<<maxEvenOdd(arr, n);
    
}

	
	
	
	
	
	
	
	
	
	
	
====================================================================================================================================================================================
	
============================================================================================================================================================================
----------------------------------------------------------------------------

IMPORTANT PROBLEM FOR REFERENCE:
 EQUILIBRIUM POINT:
 Input: 
n = 5 
A[] = {1,3,5,2,2} 
Output: 3 
Explanation: For second test case 
equilibrium point is at position 3 
as elements before it (1+3) = 
elements after it (2+2).

int equilibriumPoint(long long a[], int n) {
    
        // Your code here
        int sum = 0, lsum = 0;
        for(int i=0;i<n;i++) sum+= a[i];
        for(int i=0;i<n;i++){
            if(lsum == sum-a[i]) return i+1;
            lsum+= a[i];
            sum-= a[i];
        }
        return -1;
    }
-----------------------------------------------------------------------------------------
Frequencies of Limited Range Array Elements
Input:
N = 5
arr[] = {2, 3, 2, 3, 5}
P = 5
Output:
0 2 2 0 1
Explanation: 
Counting frequencies of each array element
We have:
1 occurring 0 times.
2 occurring 2 times.
3 occurring 2 times.
4 occurring 0 times.
5 occurring 1 time.

void frequencyCount(vector<int>& arr,int N, int P)
    { 
        // code here
        vector<int> v(N+1,0);
        for(int i=0;i<N;i++){
            if(arr[i]<=N && arr[i]>0){
                v[arr[i]]++;
            }
        }
        for(int i=1;i<N+1;i++){
            arr[i-1] = v[i];
        }
        
    }
----------------------------------------------------------------------------------------------------
You are given an array arr[] of N integers including 0. The task is to find the smallest positive number missing from the array.

Example 1:

Input:
N = 5
arr[] = {1,2,3,4,5}
Output: 6
Explanation: Smallest positive missing 
number is 6.
Example 2:

Input:
N = 5
arr[] = {0,-10,1,3,-20}
Output: 2
Explanation: Smallest positive missing 
number is 2.

There are two solutions: a simplem solution with more time:


easiest way to do this is as follows:

 

int missingNumber(int arr[], int n) 
   { 
      
       sort(arr,arr+n);
       int count=1;
       for (int i=0;i<n;i++)
       {
           if (arr[i]==count)
           count++;
       }
       return count;
   } 

Less time taking and lengthy process:

int segregateArr (int arr[], int n) 
    { 
    	int j = 0; 
    	for(int i = 0; i < n; i++) 
    	{ 
    	    if(arr[i] <= 0) 
    	    { 
    	        //changing the position of negative numbers and 0.
    	        swap(arr[i], arr[j]); 
    	        //incrementing count of non-positive integers.
    	        j++; 
    		} 
    	}
    	return j; 
    } 
    
    //Finding the smallest positive missing number in an array 
    //that contains only positive integers.
    int findMissingPositive(int arr[], int n)
    {
        
        //marking arr[i] as visited by making arr[arr[i]-1] negative. 
        //note that 1 is subtracted because indexing starts from 0 and 
        //positive numbers start from 1.
        for(int i=0; i<n; i++) 
        {
    	    if(abs(arr[i]) - 1 < n && arr[ abs(arr[i]) - 1] > 0) 
    	    arr[ abs(arr[i]) - 1] = -arr[ abs(arr[i]) - 1]; 
        } 
        
        for(int i=0; i<n; i++)
        {
            if (arr[i] > 0)
            {
                //returning the first index where value is positive. 
                // 1 is added because indexing starts from 0. 
    	        return i+1; 
            }
        }
        return n+1; 
    } 
    
    //Function to find the smallest positive number missing from the array.
    int missingNumber(int arr[], int n) 
    { 
        //first separating positive and negative numbers. 
        int shift = segregateArr(arr, n); 
        
        //shifting the array to access only positive part.
        //calling function to find result and returning it.
        return findMissingPositive(arr+shift, n-shift); 
    } 
----------------------------------------------------------------------------------------------------------------------------------
REARRANGE ARRAY ALTERNATIVELY:
	
Input:
N = 6
arr[] = {1,2,3,4,5,6}
Output: 6 1 5 2 4 3
Explanation: Max element = 6, min = 1, 
second max = 5, second min = 2, and 
so on... Modified array is : 6 1 5 2 4 3.


														DIVIDENT = DIVISOR*QUOTIENT+REMINDER
																divident = modified value in array.							// can store two values at same index
																divisor = max element of array+1
																quotient: new value to be stored
																reminder: original value.
																
																we get the original value by taking modulus of max+1 element.
																we get old value by taking floor value after dividing with max+1 element.
														eg: 1 2 3 4 5 6  // max = 6 max+1 = 6+1 = 7
															index 0 = old value = 1
																	  new value to be placed = 6
																	7*6+1 = 43 is value at index 0 now.
																	if we want new value, divide it by max+1 element = 43/7 = 6
																	if we want old value do modulus = 43%7 = 1.
															
eg: 1 2 3 4 5 6
	6 1 5 2 4 3


void rearrange(long long *arr, int n) 
    { 
    	
    	// Your code here
    	//Initialising index of first minimum and first maximum element. 
    	int max_idx = n - 1, min_idx = 0; 
    
    	//Storing maximum element of array. 
    	int max_elem = arr[n - 1] + 1; 
    
    	for (int i = 0; i < n; i++) { 
    		//At even index, we have to put maximum elements in decreasing order. 
    		if (i % 2 == 0) { 
    			arr[i] += (arr[max_idx] % max_elem) * max_elem; 
				// IMP: The reason we are doing modulus before multiplying is we might have elements that are already modified,
				so when we do modulus we get original value in that so we do modulus. eg: at 1th index we need 1(0th index) which is original value but
				since the value at 0th index is already modified and now has 43 value we do modulus and take the reminder which "1" is oroiginal value
				similarly we continue the process.
																		
				//Updating maximum index.
    			max_idx--; 
    		} 
    
    		//At odd index, we have to put minimum elements in increasing order. 
    		else { 
    			arr[i] += (arr[min_idx] % max_elem) * max_elem;
    			//Updating minimum index.
    			min_idx++; 
    		} 
    	} 
    
    	//Dividing array elements by maximum element to get the result. 
    	for (int i = 0; i < n; i++) 
    		arr[i] = arr[i] / max_elem;
    	
    	
    	
    	 
    }